import { useNetInfo } from "@react-native-community/netinfo";
import { memo, useCallback, useEffect, useRef, useState } from "react";
import { useTranslation } from "react-i18next";
import {
  ActivityIndicator,
  FlatList,
  LayoutChangeEvent,
  NativeScrollEvent,
  NativeSyntheticEvent,
  Platform,
  StyleSheet,
  ViewStyle,
} from "react-native";

import FlexActivityIndicator from "@/components/FlexActivityIndicator";
import NavHeader from "@/components/NavHeader";
import Stack from "@/components/Stack";
import { useToasts } from "@/contexts/ToastsContext";
import { warn } from "@/logger";
import { useThemeStyles } from "@/theme";

import { useChatHistory, useChatRefresh } from "../hooks/query-hooks";
import { useSendMessage } from "../hooks/use-send-message";
import { AwaitTimeData, ChatEvent, ChatResponse } from "../types";
import { combineAndFilterMessages, formatUtcTimestampToTime } from "../utils";
import AgentAwaitingMessage from "./AgentAwaitingMessage";
import AgentInformation from "./AgentInformation";
import AgentJoinedChat from "./AgentJoinedChat";
import AgentLeftChat from "./AgentLeftChat";
import BubbleMessage from "./BubbleMessage";
import ChatInputBox from "./ChatInputBox";
import ChatScrollToEndButton from "./ChatScrollToEndButton";
import ChatTypingIndicator from "./ChatTypingIndicator";
import DismissKeyboardWrapper from "./DismissKeyboardWrapper";
import SupportAgentTimer from "./SupportAgentTimer";

interface ChatListProps {
  onChatSessionError: () => void;
  onChatSessionEnd: () => void;
  initialChatData: ChatResponse;
  agentWaitingTime: AwaitTimeData;
  enquiryType: string;
  subEnquiryType: string;
  isOngoingChat?: boolean;
}
function ChatList({
  onChatSessionError,
  onChatSessionEnd,
  initialChatData,
  agentWaitingTime,
  enquiryType,
  subEnquiryType,
  isOngoingChat,
}: ChatListProps) {
  const { t } = useTranslation();
  const { isConnected } = useNetInfo();
  const addToast = useToasts();

  const { mutateAsync: refreshChatData } = useChatRefresh();
  const { mutateAsync: sendMessage } = useSendMessage();
  const { mutateAsync: getChatHistory, isLoading: getChatHistoryLoading } = useChatHistory();

  const [chatData, setChatData] = useState<ChatResponse>(initialChatData);
  const [showScrollButton, setShowScrollButton] = useState(false);
  const [isAgentTyping, setShowAgentTyping] = useState(false);
  const [isAgentOnline, setIsAgentOnline] = useState(false);
  const [showWaitingTimer, setShowWaitingTimer] = useState(true);
  const [flatListHeight, setFlatListHeight] = useState(0);

  const flatListRef = useRef<FlatList<ChatEvent> | null>(null);
  const currentOnlineAgentRef = useRef<string>(t("HelpAndSupport.AgentInformation.agentName"));
  const nextPositionRef = useRef<number>(chatData.NextPosition);
  const pendingMessagesRef = useRef<ChatEvent[]>([]);
  const chatHistoryLimitRef = useRef(1);
  const chatSessionErrorRef = useRef(false);
  const chatSessionLoadingRef = useRef(true);
  const chatStatusRef = useRef({
    showWaitingTimer,
    isAgentOnline,
    isAgentTyping,
  });

  useEffect(() => {
    if (isConnected) {
      refreshChatStatus();
      const refreshInterval = setInterval(refreshChatStatus, 3000);
      return () => {
        clearInterval(refreshInterval);
      };
    }
  }, [isConnected]);

  useEffect(() => {
    if (!isOngoingChat) {
      sendAutoGeneratedMessage();
    }
  }, []);

  useEffect(() => {
    if (isConnected === null) return;
    if (!isConnected) {
      setIsAgentOnline(false);
      onChatSessionError();
      chatSessionErrorRef.current = true;
      return;
    }
    if (chatSessionErrorRef.current) {
      addToast({
        variant: "success",
        message: t("HelpAndSupport.ChatScreen.chatConnectionBack"),
      });
      chatSessionErrorRef.current = false;
    }
    if (pendingMessagesRef.current.length > 0) {
      const sendPendingMessages = async () => {
        for (const pendingMessage of pendingMessagesRef.current) {
          try {
            await sendMessage({
              Message: pendingMessage.Text,
              TranscriptPositionIncluding: "0",
            });
          } catch (error) {
            warn("Error sending Pending Messages :", JSON.stringify(error));
          }
        }
        pendingMessagesRef.current = [];
      };
      sendPendingMessages();
    }
  }, [isConnected]);

  const refreshChatStatus = useCallback(async () => {
    try {
      const nextPosition = nextPositionRef.current;
      const refreshChatDataResponse = await refreshChatData(nextPosition);
      chatSessionLoadingRef.current = false;
      nextPositionRef.current = refreshChatDataResponse.NextPosition;
      const newMessages = refreshChatDataResponse?.Messages ? [...refreshChatDataResponse.Messages.reverse()] : [];

      if (refreshChatDataResponse.ChatEnded) {
        onChatSessionEnd();
      }

      newMessages.forEach(chatEvent => {
        if (chatEvent.From.Type === "Agent") {
          switch (chatEvent.Type) {
            case "ParticipantJoined":
              chatStatusRef.current.showWaitingTimer = false;
              chatStatusRef.current.isAgentOnline = true;
              currentOnlineAgentRef.current = chatEvent.From.Nickname;
              break;
            case "ParticipantLeft":
              chatStatusRef.current.isAgentOnline = false;
              break;
            case "TypingStarted":
              chatStatusRef.current.isAgentTyping = true;
              break;
            case "TypingStopped":
              chatStatusRef.current.isAgentTyping = false;
              break;
            default:
              chatStatusRef.current.isAgentTyping = false;
              chatStatusRef.current.isAgentOnline = true;
              break;
          }
        }
      });

      setChatData(previousChatData => ({
        ...refreshChatDataResponse,
        Messages: combineAndFilterMessages(previousChatData.Messages, newMessages),
      }));
      setIsAgentOnline(chatStatusRef.current.isAgentOnline);
      setShowWaitingTimer(chatStatusRef.current.showWaitingTimer);
      setShowAgentTyping(chatStatusRef.current.isAgentTyping);
    } catch (error) {
      warn("Error refreshing chat:", JSON.stringify(error));
    }
  }, []);

  const sendAutoGeneratedMessage = async () => {
    try {
      await sendMessage({
        Message: t("HelpAndSupport.ChatScreen.chatAutoGeneratedMessage", {
          subEnquiryType,
          enquiryType,
        }),
        TranscriptPositionIncluding: "0",
      });
      refreshChatStatus();
    } catch (error) {
      warn("Error refreshing chat:", JSON.stringify(error));
    }
  };

  const onSendMessageSuccess = useCallback(
    (pendingMessage?: ChatEvent) => {
      if (pendingMessage) {
        pendingMessagesRef.current.push(pendingMessage);
        setChatData(previousChatData => ({
          ...previousChatData,
          Messages: [pendingMessage, ...previousChatData.Messages],
        }));
        return;
      }
      refreshChatStatus();
    },
    [refreshChatStatus]
  );

  const scrollListToEnd = () => {
    if (flatListRef.current) {
      flatListRef.current.scrollToIndex({
        index: 0,
        animated: true,
        viewPosition: 1,
        viewOffset: 0,
      });
    }
  };

  const handleScroll = useCallback(
    (event: NativeSyntheticEvent<NativeScrollEvent>) => {
      const { contentOffset } = event.nativeEvent;
      if (contentOffset.y > 100 !== showScrollButton) {
        setShowScrollButton(contentOffset.y > 100);
      }
    },
    [showScrollButton]
  );

  const renderItem = useCallback(({ item }: { item: ChatEvent; index: number }) => {
    if (item.From.Type === "Client" && item.Type === "ParticipantJoined" && item.Index === 1) {
      return <AgentAwaitingMessage />;
    }
    if (item.Type === "Message" && item.From.Type !== "External") {
      return (
        <BubbleMessage
          message={item.Text}
          isAgent={item.From.Type === "Agent"}
          time={formatUtcTimestampToTime(item.UtcTime)}
          isAgentOnline={currentOnlineAgentRef.current === item.From.Nickname}
          agentName={item.From.Nickname}
        />
      );
    }
    if (item.Type === "ParticipantJoined" && item.From.Type === "Agent") {
      return <AgentJoinedChat agentName={item.From.Nickname} />;
    }
    if (item.Type === "ParticipantLeft" && item.From.Type === "Agent") {
      return <AgentLeftChat agentName={item.From.Nickname} />;
    }
    return null;
  }, []);

  const keyExtractor = useCallback((item: ChatEvent) => item.Index.toString(), []);

  const handleOnEndReached = useCallback(async (event: NativeSyntheticEvent<NativeScrollEvent>) => {
    if (event.nativeEvent.contentOffset.y > 0 && chatHistoryLimitRef.current <= 3) {
      try {
        // chatHistory is mocked data from backend, Math.random() is temporary
        const chatHistory = await getChatHistory(chatHistoryLimitRef.current);
        chatHistoryLimitRef.current += 1;
        const chatHistoryMessages = chatHistory[0].Messages.map(message => ({
          ...message,
          Index: Math.random() * 100,
        }));
        setChatData(previousChatData => ({
          ...previousChatData,
          Messages: [...previousChatData.Messages, ...chatHistoryMessages.reverse()],
        }));
      } catch (error) {
        warn("Error fetching ChatHistory:", JSON.stringify(error));
      }
    }
  }, []);

  const handleOnFlatListLayout = useCallback((event: LayoutChangeEvent) => {
    const { height: contentHeight } = event.nativeEvent.layout;
    setFlatListHeight(contentHeight);
  }, []);

  const contentContainerStyle = useThemeStyles<ViewStyle>(
    theme => ({
      padding: theme.spacing["16p"],
      flexGrow: 1,
      justifyContent: "flex-end",
      minHeight: Platform.OS === "android" ? flatListHeight + 1 : 0,
    }),
    [flatListHeight]
  );

  const ListFooterComponentStyle = useThemeStyles<ViewStyle>(theme => ({
    padding: theme.spacing["24p"],
  }));
  const navHeaderColor = useThemeStyles<string>(theme => theme.palette["neutralBase+30"]);

  return (
    <>
      <Stack direction="vertical" align="stretch" style={styles.containerStyle}>
        <DismissKeyboardWrapper>
          <NavHeader withBackButton={false} backgroundAngledColor={navHeaderColor} variant="angled">
            <AgentInformation isOnline={isAgentOnline} agentName={currentOnlineAgentRef.current} />
          </NavHeader>
        </DismissKeyboardWrapper>
        {chatSessionLoadingRef.current ? (
          <FlexActivityIndicator />
        ) : (
          <FlatList
            inverted={true}
            ref={flatListRef}
            data={chatData.Messages}
            renderItem={renderItem}
            contentContainerStyle={contentContainerStyle}
            ListHeaderComponent={
              showWaitingTimer ? <SupportAgentTimer timeInSeconds={Math.ceil(agentWaitingTime.Ewt)} /> : null
            }
            ListFooterComponent={getChatHistoryLoading ? <ActivityIndicator /> : null}
            ListFooterComponentStyle={ListFooterComponentStyle}
            keyExtractor={keyExtractor}
            onScroll={handleScroll}
            removeClippedSubviews={true}
            scrollEventThrottle={66}
            onMomentumScrollBegin={handleOnEndReached}
            onLayout={Platform.OS === "android" ? handleOnFlatListLayout : undefined}
          />
        )}
        {isAgentTyping ? (
          <DismissKeyboardWrapper>
            <ChatTypingIndicator agentName={currentOnlineAgentRef.current} />
          </DismissKeyboardWrapper>
        ) : null}
        {showScrollButton ? <ChatScrollToEndButton onPress={scrollListToEnd} /> : null}
      </Stack>
      <ChatInputBox onSendSuccess={onSendMessageSuccess} connectionStatus={isConnected} />
    </>
  );
}

const styles = StyleSheet.create({
  containerStyle: {
    flexBasis: 0,
    flexGrow: 1,
  },
});

export default memo(ChatList);
